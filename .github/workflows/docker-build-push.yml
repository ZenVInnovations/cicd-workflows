name: Centralized Docker Build and Push

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Service name (flutto-frontend or project_management_flutto)'
        required: true
        type: string
      dockerfile_path:
        description: 'Path to Dockerfile'
        required: false
        type: string
        default: './Dockerfile'
      docker_target:
        description: 'Docker build target (for multi-stage builds)'
        required: false
        type: string
        default: ''
      build_script:
        description: 'Build script path (for frontend)'
        required: false
        type: string
        default: ''
      build_context:
        description: 'Docker build context'
        required: false
        type: string
        default: '.'
      fail_on_security:
        description: 'Fail build on security vulnerabilities (HIGH,CRITICAL or empty to disable)'
        required: false
        type: string
        default: ''
      build_args:
        description: 'Docker build arguments (newline-separated, e.g. ARG1=value1\nARG2=value2)'
        required: false
        type: string
        default: ''
    outputs:
      image_tag:
        description: 'Generated image tag'
        value: ${{ jobs.build-push.outputs.image_tag }}
      environment:
        description: 'Target environment'
        value: ${{ jobs.build-push.outputs.environment }}
    secrets:
      CONTAINER_REGISTRY_TOKEN:
        required: false
      MANIFEST_UPDATE_TOKEN:
        required: false

jobs:
  build-push:
    # Use GitHub-hosted for reliability and speed (fast SSD, clean disk every build)
    # Free tier: 2000 minutes/month (plenty for startup with ~50 PRs/month)
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.tag.outputs.tag }}
      environment: ${{ steps.tag.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # FIXED: Removed docker/setup-buildx-action that requires pulling moby/buildkit image
      # Using built-in BuildKit instead (no Docker Hub dependency, no 503 errors)
      - name: Enable Docker BuildKit
        run: |
          echo "ğŸ”§ Enabling Docker BuildKit (built-in, no external image needed)"
          echo "DOCKER_BUILDKIT=1" >> $GITHUB_ENV
          docker version
          echo "âœ… BuildKit enabled"

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_REGISTRY_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Generate Environment and Tag
        id: tag
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          SHORT_SHA=${GITHUB_SHA::7}
          TIMESTAMP=$(date +%Y%m%d.%H%M%S)
          BUILD_NUMBER=${{ github.run_number }}
          PR_NUMBER=${{ github.event.pull_request.number }}

          echo "Branch: $BRANCH_NAME"
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${GITHUB_REF}"

          # GitHub Flow branching strategy
          # - Pull Request â†’ dev environment (for testing)
          # - Push to main â†’ staging environment (pre-production)
          # - Tag v*.*.* â†’ production environment (releases)

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # Pull Request - deploy to dev for preview and testing
            TAG="pr-${PR_NUMBER}-${SHORT_SHA}"
            ENVIRONMENT="development"
            ENV_TAG="dev"
            echo "ğŸ“ Pull Request #${PR_NUMBER} â†’ dev environment"

          elif [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            # Tag release (v1.0.0, v1.1.0, etc.) - production deployment
            TAG_NAME=${GITHUB_REF#refs/tags/}
            TAG="${TAG_NAME}"
            ENVIRONMENT="production"
            ENV_TAG="prod"
            echo "ğŸ·ï¸  Release tag ${TAG_NAME} â†’ production environment"

          elif [[ "$BRANCH_NAME" == "main" ]] && [[ "${{ github.event_name }}" == "push" ]]; then
            # Push to main branch - staging deployment
            TAG="main-${SHORT_SHA}"
            ENVIRONMENT="staging"
            ENV_TAG="stage"
            echo "ğŸš€ Push to main â†’ staging environment"

          elif [[ "$BRANCH_NAME" == "demo" ]]; then
            # Demo branch - special demo environment
            TAG="demo-${SHORT_SHA}"
            ENVIRONMENT="demo"
            ENV_TAG="demo"
            echo "ğŸª Demo branch â†’ demo environment"

          else
            # Feature branch (no PR yet) - deploy to dev for testing
            TAG="feature-${BRANCH_NAME//\//-}-${SHORT_SHA}"
            ENVIRONMENT="development"
            ENV_TAG="dev"
            echo "ğŸŒ¿ Feature branch â†’ dev environment"
          fi

          echo ""
          echo "=== Build Configuration ==="
          echo "Generated tag: $TAG"
          echo "Environment: $ENVIRONMENT"
          echo "Environment tag: $ENV_TAG"
          echo "=========================="

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "env_tag=$ENV_TAG" >> $GITHUB_OUTPUT

      - name: Setup Node.js and pnpm (for frontend builds)
        if: inputs.service_name == 'flutto-frontend' && inputs.build_script != ''
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm (for frontend builds)
        if: inputs.service_name == 'flutto-frontend' && inputs.build_script != ''
        run: |
          echo "ğŸ“¦ Installing pnpm..."
          npm install -g pnpm@latest
          pnpm --version

      - name: Cache pnpm dependencies
        if: inputs.service_name == 'flutto-frontend' && inputs.build_script != ''
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Debug - List repository contents
        if: inputs.service_name == 'flutto-frontend' && inputs.build_script != ''
        run: |
          echo "ğŸ” Current working directory: $(pwd)"
          echo "ğŸ“ Repository root contents:"
          ls -la
          echo "ğŸ“ Scripts directory contents:"
          ls -la scripts/ || echo "âŒ scripts/ directory not found"
          echo "ğŸ¯ Looking for build script: ${{ inputs.build_script }}"
          [ -f "${{ inputs.build_script }}" ] && echo "âœ… Build script exists" || echo "âŒ Build script NOT found"

      - name: Frontend Build (if using build script)
        if: inputs.service_name == 'flutto-frontend' && inputs.build_script != ''
        env:
          CI: true
        run: |
          echo "ğŸ”§ Running frontend build script: ${{ inputs.build_script }}"

          # Check if script exists
          if [ ! -f "${{ inputs.build_script }}" ]; then
            echo "âŒ Build script not found: ${{ inputs.build_script }}"
            echo "ğŸ“ Available files in scripts directory:"
            ls -la scripts/ || echo "scripts/ directory not found"
            echo "ğŸ“ Available files in current directory:"
            ls -la .
            exit 1
          fi

          # Make script executable and run
          chmod +x ${{ inputs.build_script }}
          ${{ inputs.build_script }}

      - name: Build Docker Image
        id: build
        env:
          DOCKER_BUILDKIT: 1
        run: |
          echo "ğŸ³ Building Docker image for ${{ inputs.service_name }}"
          echo "âœ… Using built-in BuildKit (no external dependencies)"

          # Parse build args if provided
          BUILD_ARGS=""
          if [[ -n "${{ inputs.build_args }}" ]]; then
            echo "ğŸ“‹ Processing build arguments..."
            while IFS= read -r line; do
              if [[ -n "$line" && "$line" != \#* ]]; then
                BUILD_ARGS="$BUILD_ARGS --build-arg $line"
              fi
            done <<< "${{ inputs.build_args }}"
            echo "âœ… Build args: $BUILD_ARGS"
          fi

          # FIXED: Replaced 'docker buildx build' with 'docker build'
          # This eliminates the need for pulling moby/buildkit image from Docker Hub
          # BuildKit is still enabled via DOCKER_BUILDKIT=1 environment variable

          # Build command based on service type
          if [[ "${{ inputs.service_name }}" == "project_management_flutto" ]]; then
            # Backend build with target slim
            docker build \
              -f ${{ inputs.dockerfile_path }} \
              --target slim \
              --network host \
              $BUILD_ARGS \
              -t ${{ inputs.service_name }}:${{ steps.tag.outputs.tag }} \
              ${{ inputs.build_context }}
          else
            # Frontend or generic build with BuildKit cache mounts
            if [[ -n "${{ inputs.docker_target }}" ]]; then
              docker build \
                -f ${{ inputs.dockerfile_path }} \
                --target ${{ inputs.docker_target }} \
                --network host \
                $BUILD_ARGS \
                -t ${{ inputs.service_name }}:${{ steps.tag.outputs.tag }} \
                ${{ inputs.build_context }}
            else
              docker build \
                -f ${{ inputs.dockerfile_path }} \
                --network host \
                $BUILD_ARGS \
                -t ${{ inputs.service_name }}:${{ steps.tag.outputs.tag }} \
                ${{ inputs.build_context }}
            fi
          fi

          echo "âœ… Docker build completed successfully"

      - name: Security Scan Local Image
        if: inputs.fail_on_security != ''
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ inputs.service_name }}:${{ steps.tag.outputs.tag }}'
          format: 'table'
          severity: ${{ inputs.fail_on_security }}
          exit-code: '1'
          output: 'trivy-scan-results.txt'

      - name: Display Security Scan Results
        if: always() && inputs.fail_on_security != ''
        run: |
          echo "ğŸ”’ Security Scan Results"
          if [[ -f "trivy-scan-results.txt" ]]; then
            cat trivy-scan-results.txt
          else
            echo "âš ï¸ No scan results found"
          fi

      - name: Security Gate Check
        if: inputs.fail_on_security != ''
        run: |
          echo "ğŸšª Security gate enabled for: ${{ inputs.fail_on_security }}"
          echo "âœ… Image passed security scan - proceeding with push"

      - name: Tag Images for GHCR
        run: |
          echo "ğŸ·ï¸ Tagging images for GHCR"

          # Tag with specific version
          docker tag ${{ inputs.service_name }}:${{ steps.tag.outputs.tag }} \
            ghcr.io/zenvinnovations/${{ inputs.service_name }}:${{ steps.tag.outputs.tag }}

          # Tag with environment
          docker tag ${{ inputs.service_name }}:${{ steps.tag.outputs.tag }} \
            ghcr.io/zenvinnovations/${{ inputs.service_name }}:${{ steps.tag.outputs.env_tag }}

      - name: Push to GHCR
        run: |
          echo "ğŸ“¤ Pushing images to GHCR"

          # Show what we're about to push
          echo "ğŸ” Images to push:"
          echo "  - ghcr.io/zenvinnovations/${{ inputs.service_name }}:${{ steps.tag.outputs.tag }}"
          echo "  - ghcr.io/zenvinnovations/${{ inputs.service_name }}:${{ steps.tag.outputs.env_tag }}"

          # Show local images
          echo "ğŸ” Local images available:"
          docker images | grep ${{ inputs.service_name }} || echo "No local images found"

          # Push specific version tag
          echo "ğŸ“¤ Pushing specific tag: ${{ steps.tag.outputs.tag }}"
          if docker push ghcr.io/zenvinnovations/${{ inputs.service_name }}:${{ steps.tag.outputs.tag }}; then
            echo "âœ… Successfully pushed specific tag"
          else
            echo "âŒ Failed to push specific tag"
            exit 1
          fi

          # Push environment tag
          echo "ğŸ“¤ Pushing environment tag: ${{ steps.tag.outputs.env_tag }}"
          if docker push ghcr.io/zenvinnovations/${{ inputs.service_name }}:${{ steps.tag.outputs.env_tag }}; then
            echo "âœ… Successfully pushed environment tag"
          else
            echo "âŒ Failed to push environment tag"
            exit 1
          fi

          echo "âœ… Successfully pushed all images:"
          echo "  - ghcr.io/zenvinnovations/${{ inputs.service_name }}:${{ steps.tag.outputs.tag }}"
          echo "  - ghcr.io/zenvinnovations/${{ inputs.service_name }}:${{ steps.tag.outputs.env_tag }}"

      - name: Update Deployment Manifests
        # DISABLED: ArgoCD Image Updater handles image updates via write-back-method: argocd
        # This step was updating the wrong repository (flutto-deployment-manifests instead of flutto-gitops)
        # Image Updater automatically detects new image digests and updates Application parameters
        if: false
        run: |
          echo "âš ï¸ Manifest updates disabled - handled by ArgoCD Image Updater"
          echo "ArgoCD Image Updater polls GHCR every 2 minutes and updates deployments automatically"
          echo "See: /home/flutto-gitops/docs/CD-COMPLETE-GUIDE.md for details"

      - name: Create Deployment Summary
        run: |
          echo "## ğŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Service | ${{ inputs.service_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ steps.tag.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | ${{ steps.tag.outputs.tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | ${GITHUB_REF#refs/heads/} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ steps.tag.outputs.environment }}" != "pr" && "${{ steps.tag.outputs.environment }}" != "feature" ]]; then
            echo "### ğŸŒ Deployment URLs" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            case "${{ inputs.service_name }}" in
              "flutto-frontend")
                case "${{ steps.tag.outputs.environment }}" in
                  "production") echo "- **Production**: https://zenv.flutto.ai" >> $GITHUB_STEP_SUMMARY ;;
                  "staging") echo "- **Staging**: https://staging.flutto.ai" >> $GITHUB_STEP_SUMMARY ;;
                  "development") echo "- **Development**: https://dev.flutto.ai" >> $GITHUB_STEP_SUMMARY ;;
                esac
                ;;
              "project_management_flutto")
                case "${{ steps.tag.outputs.environment }}" in
                  "production")
                    echo "- **Production API**: https://backend.flutto.ai" >> $GITHUB_STEP_SUMMARY
                    echo "- **Health Check**: https://backend.flutto.ai/health_checks/default" >> $GITHUB_STEP_SUMMARY
                    ;;
                  "staging")
                    echo "- **Staging API**: https://stage-backend.flutto.ai" >> $GITHUB_STEP_SUMMARY
                    echo "- **Health Check**: https://stage-backend.flutto.ai/health_checks/default" >> $GITHUB_STEP_SUMMARY
                    ;;
                  "development")
                    echo "- **Development API**: https://develop-backend.flutto.ai" >> $GITHUB_STEP_SUMMARY
                    echo "- **Health Check**: https://develop-backend.flutto.ai/health_checks/default" >> $GITHUB_STEP_SUMMARY
                    ;;
                esac
                ;;
            esac
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ¯ **Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "- ArgoCD will automatically sync and deploy within 3 minutes" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor deployment in ArgoCD dashboard" >> $GITHUB_STEP_SUMMARY
          echo "- Verify application health at the URLs above" >> $GITHUB_STEP_SUMMARY
